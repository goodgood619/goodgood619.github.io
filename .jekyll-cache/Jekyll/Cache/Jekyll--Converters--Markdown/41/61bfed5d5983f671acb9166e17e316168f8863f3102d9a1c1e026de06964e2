I"<p>LCA는 최소 공통 조상을 뜻하며, 영어로는 Least Common Ancestor? 뭐 이런 의미 인거 같다</p>

<p>​그럼 반대로 최대 공통 조상이란 말이 있을까라는 생각이 든다. 그런데, 사실 최대 공통조상의 정답은 너무 간단하다. 왜냐하면 항상 루트일것이기 때문이다</p>

<p>​그러면 LCA를 통해서 무엇을 할수 있을것인가? 라는 고민이 문득 든다</p>

<p>​이런 문제의 경우에 아주 적합할 것 같다</p>

<p><a href="&quot;https://www.acmicpc.net/problem/11438&quot;">BOJ LCA 2</a></p>

<p>문제부터 대놓고 LCA 2이지만,</p>

<p>이 문제는 트리의 형태로 주어졌을때, 입력되는 쿼리에 대해서 최소 공통 조상을 빠르게 찾아야 한다는 문제이다</p>

<p>뭐 사실, 최소 공통조상이 아니고, 그냥 입력되는 쿼리의 사이의 거리를 구한다는 이런 유형의 문제가</p>

<p>거의 LCA관련 문제라고 생각한다(단, 입력되는 쿼리수가 많고, 구성하고 있는 트리의 노드 갯수도 많아야한다는 가정)</p>

<p>우리가 LCA를 모른다면, 일반적으로 생각하기에</p>

<p>매번 입력받는 쿼리마다 DFS혹은 BFS를 돌려서, 최소 공통 조상을 찾게된다</p>

<p>즉 그러면 시간복잡도는 대략, V: 노드 갯수, E:엣지 갯수, Q:쿼리 갯수라고 가정하면</p>

<p>O(Q(V+E)) 라는 시간 복잡도가 나올것이며, Q가 10000개만 넘어간다고 해도, 시간이 정말 많이 걸릴것이다</p>

<p>​</p>

<p>그래서, 이런 문제를 빠르게 해결하기 위해서 LCA를 통해 해결할수 있는데,</p>

<p>LCA 시간복잡도는 우선 좀있다가 보기로 하고,</p>

<p>LCA를 한번 구해야 한다. 근데, LCA가 어려울수 있는점이 LCA를 하기전에 2가지 Step이 필요하다!!</p>

<p>​</p>

<ol>
  <li>
    <p>dp[i][j]의 정의를 명확히 세우고 알아야 하는점</p>
  </li>
  <li>
    <p>DFS or BFS를 돌려서 바로 자신의 부모의 정보를 갱신해야 한다는점이다</p>
  </li>
</ol>

<p>​</p>

<p>이 2가지를 한다음에, 마지막에 LCA를 구한다면 올바르게 구할수 있음을 알수 있다</p>

<p>​</p>

<p>우선 dp[i][j]의 정의를 세워야 한다</p>

<p>​Dynamic Programming의 수준까지는 아니지만, 뭔가 DP의 성질이 조금 반영은 되는데,</p>

<p>저 정의를 세우기 전에 이런 생각을 하게 된다</p>

<p>(어떻게 해야 목표 노드까지 빠르게 도달을 하지? -&gt; 일일이 DFS or BFS를 돌릴순 없어 -&gt; LCA를 대충 읽어보니 최소 공통조상 어쩌고 저쩌고네 -&gt; 그러면 해당 i번째 노드에서 j번째위에 있는 조상이라고 정의하면 뭔가 그럴싸하지 않을까?)</p>

<p>​이런 생각이 든다. 처음 배울때는 그런 생각이 들었다. 그런데, 저런 식의 정의를 세우면 , j가 10만일경우</p>

<p>dp[10만][10만] 이런 말도 안되는 경우가 나오게 된다(애초에 배열 선언도 안될지도 모름, 사실 안해봤음)</p>

<p>​
그러면 어떻게 해야 내 위에 있는 모든 조상들로 올바르게 접근을 할수 있을것인가 ? 라는 생각이 든다</p>

<p>​이거는 컴퓨터의 성질인 2진수에 따른다고 생각을 한다(그냥 제 생각)</p>

<p>그렇다면 검증을 해봐야 한다</p>

<p><strong>dp[i][j]: i번째 노드의 2^j(2의 j승)번째 조상의 노드 번호</strong> 라고 정의를 해본다</p>

<p>그러면 i번째 노드의 50번째 조상을 찾는다고 생각을 해본다</p>

<p>​그러면 50이란 숫자는 50=32+16+2 로 표현이 될것이다</p>

<p>즉, 32번째 조상으로 올라간다음, 그위치에서 다시 16번째 조상으로 올라간다음, 2번째 조상으로 올라가게 된다면</p>

<p>우리는 올바르게 i번째 위로 있는 모든 조상들을 올바르게 찾아낼 수 있을것이다</p>

<p>그러면 이제 이 작업을 하기 위해서</p>

<p>먼저 DFS 혹은 BFS를 통해, 바로 윗 부모가 누구인지 파악을 해주는 작업이 필요하다</p>

<p>DFS혹은 BFS를 돌리면서, 현재 위치의 노드와 바로 전 위치의 노드를 같이 가지고 간다면,</p>

<p>바로 윗부모의 정보를 올바르게 갱신시킬수 있을것이다</p>

<p>그리고 여기서 빠뜨린게 있는데, 해당 노드가 깊이가 얼마인지를 파악하는것이 중요하다</p>

<p>이것은 좀있다가 아래서 설명을 하도록 하겠다</p>
:ET
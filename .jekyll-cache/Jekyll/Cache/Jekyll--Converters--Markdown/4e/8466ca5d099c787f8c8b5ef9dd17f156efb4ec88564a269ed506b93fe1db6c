I"a#<h2 id="java-lambda">Java Lambda</h2>

<p>Lambda : <strong>익명 함수(anonymous function)을 생성하기 위한 식</strong>으로, 객체 지향 언어보다는 함수 지향 언어에 가까움</p>

<p>그런데 왜 자바에서 이런 람다식을 수용한 것인가?</p>

<ol>
  <li>자바 코드가 매우 간결해짐</li>
  <li>컬렉션의 요소를 필터링하거나 매핑해서 결과 집계를 쉽게 가능하게 함</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// 람다식 -&gt; 매개 변수를 가진 코드 블록 -&gt; 익명 구현 객체</span>

<span class="nc">Runnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// new 부터의 형태가 익명 구현객체이다</span>
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
			<span class="c1">//어쩌고..</span>
		<span class="o">}</span>
<span class="o">};</span>

<span class="c1">// 그러나 람다식으로 가게 되면</span>

<span class="nc">Runnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{...};</span>
</code></pre></div></div>

<h3 id="기본-문법">기본 문법</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (타입 매개변수, ...)-&gt;{실행문; ...}</span>
<span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);}</span>
<span class="c1">// 매개변수타입은 런타임시에 자동으로 인식되어서, 일반적으로는 매개변수타입은 넣지 않는다</span>
<span class="o">(</span><span class="n">a</span><span class="o">)-&gt;{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);}</span>
<span class="c1">// 매개변수가 1개이고, 만약 실행문이 한개면 ()괄호와 {}괄호는 생략이 가능하다</span>
<span class="n">a</span><span class="o">-&gt;</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
<span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)-&gt;{</span><span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">;}</span> <span class="c1">// 만약 리턴문이 있는데, 리턴문만 있다면</span>
<span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)-&gt;</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span> <span class="o">;</span> <span class="c1">// 로 바꿀수있다.</span>
</code></pre></div></div>

<p>람다식은 하나의 메소드를 정의하기 때문에, <strong>두 개 이상의 추상 메소드가 선언된 인터페이스는 람다식을 이용해서 구현 객체를 생성할수 없다. 그래서 하나의 추상 메소드만 가능하다.</strong> (여기서 착각하지 말아야 할 부분은 디폴트 메소드나 정적 메소드는 포함이 되지않는다. <strong>즉, 디폴트 메소드와 정적 메소드는 몇개 이상이 추가되어도 상관이 없다는 말</strong>임)</p>

<p>이 때, 함수적 인터페이스를 작성할때, <strong>두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체킹해주는 기능</strong>이 있다. <strong>@Functional 이라는 annotation</strong>을 붙이면 된다</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MyFunctionalInterface</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">();</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">otherMethod</span><span class="o">();</span> <span class="c1">// 컴파일 에러</span>

<span class="o">}</span>
</code></pre></div></div>

<hr />

<p>함수적 인터페이스는 크게 Consumer, Supplier, Function, Operator, Predicate로 구분된다. 구분 기준은 인터페이스에 선언된 추상 메소드의 매개값과 리턴값의 유무이다.</p>

<p><img src="/assets/Lambda_Interface.png" alt="Lambda_대표적인터페이스" /></p>

<p>저 인터페이스들을 이용해서 그냥 각각의 경우만 처리하면 그닥 큰 쓸모가 없을수도 있다. 그래서 Consumer, Function, Operator 종류의 함수적 인터페이스는 andThen()과 compose() 디폴트 메소드를 가지고 있다.</p>

<p>먼저 andThen()의 경우는, 첫번째 인터페이스의 일을 먼저 처리한후, 두 번째 매개값으로 제공해 최종 결과를 얻을 때 사용</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">인터페이스AB</span> <span class="o">=</span> <span class="n">인터페이스A</span><span class="o">.</span><span class="na">andThen</span><span class="o">(</span><span class="n">인터페이스B</span><span class="o">);</span> <span class="c1">// 인터페이스A의 메소드를 먼저 실행한뒤에 인터페이스 B의 메소드를 실행</span>
<span class="n">최종결과</span> <span class="o">=</span> <span class="n">인터페이스AB</span><span class="o">.</span><span class="na">method</span><span class="o">();</span> 

<span class="n">인터페이스AB</span> <span class="o">=</span> <span class="n">인터페이스A</span><span class="o">.</span><span class="na">compose</span><span class="o">(</span><span class="n">인터페이스B</span><span class="o">);</span> <span class="c1">// 인터페이스B의 메소드를 먼저 실행한뒤에 인터페이스 A의 메소드를 실행</span>
<span class="n">최종결과</span> <span class="o">=</span> <span class="n">인터페이스AB</span><span class="o">.</span><span class="na">method</span><span class="o">();</span>
</code></pre></div></div>

<p><img src="/assets/Lambda_andThen_compose.png" alt="Lambda_andThen_compose" /></p>

<p>메소드 참조(Method References) : 말 그대로 <strong>메소드를 참조</strong>해서 <strong>매개 변수의 정보 및 리턴 타입을 알아내어, 람다식에서 불필요한 매개 변수를 제거</strong>하는 것이 목적이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">left</span><span class="o">,</span><span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">left</span><span class="o">,</span><span class="n">right</span><span class="o">);</span> <span class="c1">// Lambda Expression</span>
<span class="nl">Math:</span><span class="o">:</span><span class="n">max</span><span class="o">;</span> <span class="c1">// Method References</span>
</code></pre></div></div>

<p>메소드 참조도 람다식과 마찬가지로 인터페이스의 익명 구현 객체로 생성이 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">클래스이름</span> <span class="o">::</span> <span class="n">메소드</span> <span class="c1">// static(정적) 메소드를 참조할 경우</span>
<span class="n">참조변수</span> <span class="o">::</span> <span class="n">메소드</span> <span class="c1">// 인스턴스 메소드를 참조할경우, 저기서 참조변수는 사실상, new 연산자로 할당된 인스턴스 이름을 의미할것이다.</span>
<span class="n">클래스</span> <span class="o">::</span> <span class="k">new</span> <span class="c1">// (a,b) -&gt; return new 클래스(a,b); 만약 해당 생성자가 존재하지 않으면 컴파일 에러!!</span>
</code></pre></div></div>

<p>위와 관련한 모든 예제들은 아래 링크 주소에 있으니 참고해주시면 감사하겠습니다.<br />
<a href="https://github.com/goodgood619/ThisIsJava">https://github.com/goodgood619/ThisIsJava</a></p>
:ET